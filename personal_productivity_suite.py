# -*- coding: utf-8 -*-
"""Personal Productivity Suite.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kGh9mymRMZm486yjYVq8FNxkwXJRMew6
"""

import streamlit as st
import json
from datetime import datetime, time, timedelta
import pandas as pd
import altair as alt
import requests

# --- STATE MANAGEMENT ---
# Initialize session state to hold data for the activity tracker
if 'all_data' not in st.session_state:
    st.session_state.all_data = {}

# --- GEMINI API FUNCTION (Activity Tracker) ---
def get_activities_from_text(prompt, api_key):
    """
    Calls the Gemini API to extract structured activity data from a text prompt.
    """
    if not api_key:
        st.error("Please enter your Gemini API key in the sidebar to use this feature.")
        return None

    api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key={api_key}"

    schema = {
        "type": "ARRAY",
        "items": {
            "type": "OBJECT",
            "properties": {
                "task": {"type": "STRING", "description": "A concise description of the activity."},
                "category": {
                    "type": "STRING",
                    "enum": ["Health", "Mobile", "Food", "Sleeping", "Work", "Leisure", "Reading", "Other"],
                    "description": "The most appropriate category for the activity."
                },
                "start_time": {"type": "STRING", "description": "The start time in HH:MM format (24-hour clock)."},
                "end_time": {"type": "STRING", "description": "The end time in HH:MM format (24-hour clock)."}
            },
            "required": ["task", "category", "start_time", "end_time"]
        }
    }

    system_prompt = "You are an expert at parsing a user's description of their day and converting it into a structured JSON format based on the provided schema. Infer times and categories logically. The current year is 2025."

    payload = {
        "contents": [{"parts": [{"text": f"Parse the following text and extract all activities: {prompt}"}]}],
        "systemInstruction": {"parts": [{"text": system_prompt}]},
        "generationConfig": {"responseMimeType": "application/json", "responseSchema": schema}
    }

    try:
        response = requests.post(api_url, json=payload, headers={'Content-Type': 'application/json'})
        response.raise_for_status()
        result = response.json()
        json_text = result.get('candidates', [{}])[0].get('content', {}).get('parts', [{}])[0].get('text', '[]')
        return json.loads(json_text)
    except requests.exceptions.RequestException as e:
        st.error(f"API request failed: {e}")
        st.error(f"Response Body: {response.text if 'response' in locals() else 'No response'}")
        return None
    except (json.JSONDecodeError, IndexError, KeyError) as e:
        st.error(f"Failed to parse AI response. Please try rephrasing your prompt. Error: {e}")
        st.json(result)
        return None

# --- GEMINI API FUNCTION (News Analysis) ---
def generate_news_report_and_post(topic, api_key):
    """
    Calls Gemini API with Google Search to generate a detailed report and a LinkedIn post.
    """
    if not api_key:
        st.error("Please enter your Gemini API key in the sidebar.")
        return None, None

    api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key={api_key}"

    # New prompt for McKinsey-style report and LinkedIn post
    prompt = f"""
    Act as a senior strategy consultant from a top-tier firm like McKinsey & Company.
    Your task is to analyze the absolute latest global news and developments on the topic: '{topic}'.
    Based on your comprehensive web search, generate a structured report and a corresponding LinkedIn post.
    The final output MUST be a single JSON object matching the provided schema.

    1.  **In-Depth Report**:
        * **Report Title**: Create a professional, impactful title for the report.
        * **Executive Summary**: A concise, high-level overview of the key findings and their implications.
        * **Key Developments**: List 3-5 of the most critical recent developments or news items.
        * **Market Impact**: Analyze the immediate and potential long-term impact of these developments on the market.
        * **Future Outlook**: Provide strategic insights into what might happen next and potential challenges.

    2.  **LinkedIn Post**:
        * Based on the report, write a concise, powerful, and professional LinkedIn post.
        * Conclude with 3-5 relevant and popular hashtags.
    """

    # New schema for structured output
    schema = {
        "type": "OBJECT",
        "properties": {
            "report_title": {"type": "STRING"},
            "executive_summary": {"type": "STRING"},
            "key_developments": {
                "type": "ARRAY",
                "items": {"type": "STRING"}
            },
            "market_impact": {"type": "STRING"},
            "future_outlook": {"type": "STRING"},
            "linkedin_post": {"type": "STRING"}
        },
        "required": ["report_title", "executive_summary", "key_developments", "market_impact", "future_outlook", "linkedin_post"]
    }

    payload = {
        "contents": [{"parts": [{"text": prompt}]}],
        "tools": [{"google_search": {}}],
        "generationConfig": {
            "responseMimeType": "application/json",
            "responseSchema": schema
        }
    }

    try:
        response = requests.post(api_url, json=payload, headers={'Content-Type': 'application/json'})
        response.raise_for_status()
        result = response.json()

        candidate = result.get('candidates', [{}])[0]
        content_text = candidate.get('content', {}).get('parts', [{}])[0].get('text', '{}')
        report_data = json.loads(content_text)

        citations = []
        grounding_metadata = candidate.get('groundingMetadata', {})
        if grounding_metadata and 'groundingAttributions' in grounding_metadata:
             for attribution in grounding_metadata['groundingAttributions']:
                 title = attribution.get('web', {}).get('title', 'No Title')
                 uri = attribution.get('web', {}).get('uri', '#')
                 citations.append({"title": title, "uri": uri})

        if not report_data:
             st.error("The model did not return a valid report. Please try a different topic.")
             return None, None

        return report_data, citations
    except requests.exceptions.RequestException as e:
        st.error(f"API request failed: {e}")
        try:
            error_details = response.json()
            st.error(f"API Error Details: {error_details.get('error', {}).get('message', 'No specific message.')}")
        except (ValueError, AttributeError):
             st.error(f"Response Body: {response.text if 'response' in locals() else 'No response'}")
        return None, None
    except (json.JSONDecodeError, IndexError, KeyError) as e:
        st.error(f"Failed to parse AI response. The model's output may be malformed. Error: {e}")
        st.json(result)
        return None, None

# --- UI LAYOUT ---
st.set_page_config(page_title="Personal Productivity Suite", page_icon="🚀", layout="wide")
st.title("🚀 Personal Productivity Suite")

# --- SIDEBAR NAVIGATION ---
st.sidebar.header("Navigation & Settings")
app_choice = st.sidebar.radio("Choose your tool", ("Daily Activity Dashboard", "AI News Assistant"))
api_key = st.sidebar.text_input("Gemini API Key", type="password", help="A single API key for all tools.")


# --- RENDER THE CHOSEN APP ---

if app_choice == "Daily Activity Dashboard":
    st.markdown("Log your day, track goals, and build healthy habits.")
    selected_date = st.sidebar.date_input("Select a date", datetime.now())
    date_key = selected_date.strftime("%Y-%m-%d")

    if date_key not in st.session_state.all_data:
        st.session_state.all_data[date_key] = {"activities": [], "reminders": []}

    st.header(f"Dashboard for: `{selected_date.strftime('%B %d, %Y')}`")
    activities = st.session_state.all_data[date_key].get("activities", [])

    if activities:
        df = pd.DataFrame(activities)
        df['duration_hours'] = df['duration_minutes'] / 60
        category_summary = df.groupby('category')['duration_hours'].sum()

        st.subheader("Time Spent (Hours)")
        cols = st.columns(6)
        categories = ["Health", "Mobile", "Food", "Sleeping", "Work", "Reading"]
        icons = ["❤️", "📱", "🍔", "😴", "💼", "📚"]
        for i, (col, category, icon) in enumerate(zip(cols, categories, icons)):
            total_hours = category_summary.get(category, 0)
            col.metric(label=f"{icon} {category}", value=f"{total_hours:.2f} hrs")

        st.markdown("---")
        st.subheader("🏆 Healthy Day Status")
        health_hours = category_summary.get("Health", 0)
        sleep_hours = category_summary.get("Sleeping", 0)
        mobile_hours = category_summary.get("Mobile", 0)
        reading_hours = category_summary.get("Reading", 0)

        health_goal_hours, sleep_goal_hours, mobile_limit_hours, reading_goal_hours = 1.0, 7.0, 2.0, 0.5
        health_achieved = health_hours >= health_goal_hours
        sleep_achieved = sleep_hours >= sleep_goal_hours
        mobile_achieved = mobile_hours <= mobile_limit_hours
        reading_achieved = reading_hours >= reading_goal_hours

        col1, col2, col3, col4 = st.columns(4)
        with col1: st.metric(label="💪 Health Activity Goal", value=f"{health_hours:.1f} / {health_goal_hours} hrs", delta=f"{(health_hours - health_goal_hours):.1f} hrs")
        with col2: st.metric(label="😴 Sleep Goal", value=f"{sleep_hours:.1f} / {sleep_goal_hours} hrs", delta=f"{(sleep_hours - sleep_goal_hours):.1f} hrs")
        with col3: st.metric(label="📱 Mobile Limit", value=f"{mobile_hours:.1f} / {mobile_limit_hours} hrs", delta=f"{(mobile_hours - mobile_limit_hours):.1f} hrs", delta_color="inverse")
        with col4: st.metric(label="📚 Reading Goal", value=f"{reading_hours:.1f} / {reading_goal_hours} hrs", delta=f"{(reading_hours - reading_goal_hours):.1f} hrs")

        if all([health_achieved, sleep_achieved, mobile_achieved, reading_achieved]):
            st.success("🎉 Congratulations! You hit all your healthy day goals! Keep up the great work.")
            st.balloons()
        else:
            st.warning("You're on your way! Focus on the areas needing improvement to achieve a healthy day.")

        st.markdown("---")
        st.subheader("Daily Activity Breakdown")
        chart = alt.Chart(df).mark_arc(innerRadius=50).encode(
            theta=alt.Theta(field="duration_minutes", type="quantitative"),
            color=alt.Color(field="category", type="nominal", title="Category"),
            tooltip=['task', 'category', 'duration_minutes']
        ).properties(width=700, height=400)
        st.altair_chart(chart, use_container_width=True)
    else:
        st.info("No activities recorded for this day. Use the tabs below to add activities.")

    tab_ai, tab_manual, tab_reminders = st.tabs(["🤖 Log with AI", "📝 Activities List", "⏰ Reminders"])
    with tab_ai:
        st.header("Describe Your Day")
        prompt = st.text_area("Enter your activities here:", placeholder="e.g., Woke up and went for a run from 7 to 7:45am, had breakfast...", height=150)
        if st.button("Generate Activity Log"):
            if prompt and api_key:
                with st.spinner("🧠 Analyzing your day..."):
                    parsed_activities = get_activities_from_text(prompt, api_key)
                    if parsed_activities:
                        for activity in parsed_activities:
                            try:
                                start_time_val = datetime.strptime(activity['start_time'], "%H:%M").time()
                                end_time_val = datetime.strptime(activity['end_time'], "%H:%M").time()
                                start_dt, end_dt = datetime.combine(selected_date, start_time_val), datetime.combine(selected_date, end_time_val)
                                if end_time_val < start_time_val: end_dt += timedelta(days=1)
                                duration = (end_dt - start_dt).total_seconds() / 60
                                if duration >= 0:
                                    st.session_state.all_data[date_key]['activities'].append({"task": activity['task'], "category": activity['category'], "start_time": activity['start_time'], "end_time": activity['end_time'], "duration_minutes": duration})
                            except (ValueError, KeyError): pass
                        st.success("Successfully added activities!")
                        st.rerun()
    with tab_manual:
        st.header("Manage Activities")
        if activities:
            for i, activity in enumerate(activities):
                cols = st.columns([0.6, 0.2, 0.1, 0.1])
                cols[0].markdown(f"**{activity['task']}**")
                cols[1].info(f"{activity['category']} | {activity['duration_minutes']:.0f} mins")
                cols[2].write(f"_{activity['start_time']} - {activity['end_time']}_")
                if cols[3].button("🗑️", key=f"del_act_{i}"):
                    st.session_state.all_data[date_key]["activities"].pop(i)
                    st.rerun()
        with st.form("activity_form", clear_on_submit=True):
            cols = st.columns([2, 1, 1, 1])
            task = cols[0].text_input("Activity Name")
            category = cols[1].selectbox("Category", ["Health", "Mobile", "Food", "Sleeping", "Work", "Leisure", "Reading", "Other"])
            start_time_val, end_time_val = cols[2].time_input("Start Time", time(9, 0)), cols[3].time_input("End Time", time(10, 0))
            if st.form_submit_button("Add Activity Log"):
                if task:
                    start_dt, end_dt = datetime.combine(selected_date, start_time_val), datetime.combine(selected_date, end_time_val)
                    if end_time_val < start_time_val: end_dt += timedelta(days=1)
                    duration = (end_dt - start_dt).total_seconds() / 60
                    if duration >= 0:
                        st.session_state.all_data[date_key]["activities"].append({"task": task, "category": category, "start_time": start_time_val.strftime("%H:%M"), "end_time": end_time_val.strftime("%H:%M"), "duration_minutes": duration})
                        st.rerun()
    with tab_reminders:
        st.header("Manage Reminders")
        with st.form("reminder_form", clear_on_submit=True):
            cols = st.columns([3, 1])
            reminder_text = cols[0].text_input("Reminder")
            reminder_time = cols[1].time_input("Time")
            if st.form_submit_button("Add Reminder"):
                if reminder_text:
                    st.session_state.all_data[date_key]["reminders"].append({"text": reminder_text, "time": reminder_time.strftime("%H:%M"), "completed": False})
                    st.rerun()
        reminders = st.session_state.all_data[date_key].get("reminders", [])
        if reminders:
            for i, reminder in enumerate(reminders):
                cols = st.columns([0.05, 0.8, 0.15])
                is_completed = cols[0].checkbox("", value=reminder.get("completed", False), key=f"rem_complete_{i}")
                if is_completed != reminder.get("completed", False):
                    st.session_state.all_data[date_key]["reminders"][i]["completed"] = is_completed
                    st.rerun()
                text = f"~~{reminder['text']}~~" if is_completed else reminder['text']
                time_text = f"<small style='color:grey;'> at {datetime.strptime(reminder['time'], '%H:%M').strftime('%I:%M %p')}</small>"
                cols[1].markdown(f"{text}{text_time}", unsafe_allow_html=True)
                if cols[2].button("🗑️", key=f"del_rem_{i}"):
                    st.session_state.all_data[date_key]["reminders"].pop(i)
                    st.rerun()

elif app_choice == "AI News Assistant":
    st.markdown("Enter a topic to generate a detailed news analysis and a ready-to-share LinkedIn post.")
    topic = st.text_input("Enter your topic (e.g., 'global trends in artificial intelligence'):", "")

    if st.button("Generate Master Report & Post", type="primary"):
        if topic:
            with st.spinner("🤖 Consulting global sources and drafting your report..."):
                report_data, citations = generate_news_report_and_post(topic, api_key)
                if report_data:
                    st.subheader("Master Report")
                    st.markdown(f"### {report_data.get('report_title', 'No Title')}")

                    st.markdown("---")

                    st.markdown("#### Executive Summary")
                    st.markdown(report_data.get('executive_summary', ''))

                    st.markdown("#### Key Developments")
                    for point in report_data.get('key_developments', []):
                        st.markdown(f"- {point}")

                    st.markdown("#### Market Impact")
                    st.markdown(report_data.get('market_impact', ''))

                    st.markdown("#### Future Outlook")
                    st.markdown(report_data.get('future_outlook', ''))

                    st.markdown("---")

                    st.subheader("Ready-to-Share LinkedIn Post")
                    st.markdown("""
                        <style>
                        .post-container { border: 1px solid #e1e4e8; border-radius: 8px; padding: 20px; background-color: #ffffff; box-shadow: 0 4px 6px rgba(0,0,0,0.05); margin-bottom: 20px; }
                        .post-container p { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.6; color: #24292e; white-space: pre-wrap; }
                        </style>
                    """, unsafe_allow_html=True)
                    formatted_post = report_data.get('linkedin_post', '')
                    st.markdown(f'<div class="post-container"><p>{formatted_post}</p></div>', unsafe_allow_html=True)

                    if citations:
                        with st.expander("📰 View Data Sources"):
                            for i, source in enumerate(citations):
                               st.markdown(f"[{i+1}. {source['title']}]({source['uri']})")
        else:
            st.warning("Please enter a topic to generate a report.")